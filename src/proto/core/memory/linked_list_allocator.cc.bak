
#include "proto/core/memory/linked_list_allocator.hh"
#include <assert.h>

using namespace proto::memory;

int linked_list_allocator::init(size_t init_size)
{
    assert(_arena == nullptr and
            _size  == 0);
    assert(init_size > (2 * sizeof(header) + _min_block_size));

    _arena = (void*) malloc(init_size);

    _min_alloc_size =
        _min_block_size +
        (2 * sizeof(header) - 1) +
        (max_alignment - 1);

    if(_arena) {
        assert(is_aligned(_arena, 16));
        _size = init_size;


#if defined(PROTO_DEBUG)
        for(size_t i = 0; i < _size; i++) {
            *((byte*)_arena + i) = 0;
        }
#endif

        void * init_block = align_forw((void*)((byte*)_arena + sizeof(header)),
                                        max_alignment);

        header * init_header = (header*) align_back(init_block, alignof(header));

        size_t init_offset = ((byte*)init_block - (byte*)_arena);

        assert( init_offset < _size );

        init_header->size = _size - init_offset;
        init_header->next = nullptr;
        init_header->next_in_mem = nullptr;
        init_header->flags = header::FREE;


        _first = init_block;
        _last = init_block;

        return 0;
    } else {
        return 1;
    }
}

void * linked_list_allocator::raw() {
    return _arena;
}

void * linked_list_allocator::alloc(size_t requested_size, size_t alignment)
{
    // assert(is_power_of_two(alignment));

    assert(_arena != nullptr);
    assert(_first != nullptr);
    assert(_size  != 0);

    if(requested_size < _min_block_size) return nullptr;

    void * block = _first;
    void * prev_block = nullptr;
    do{
        header * block_header = get_header(block);

        if( block_header->size > requested_size ) {
            bool split = false;
            void * new_block = nullptr;
            header * new_block_header = nullptr;

            if(block_header->size - requested_size > _min_alloc_size) {
                split = true;

                byte * bcursor = (byte*)
                    align_forw((void*)((byte*) block + requested_size),
                                        alignof(header));

                new_block = align_forw((void*)(bcursor + sizeof(header)),
                                        alignment);

                new_block_header = get_header(new_block);

                size_t residue = (byte*)new_block_header - bcursor;

                new_block_header->size =
                    ((byte*)block + block_header->size) - (byte*)new_block;
                new_block_header->next_in_mem = block_header->next_in_mem;

                block_header->size = requested_size + residue;
                block_header->next_in_mem = new_block_header;

                new_block_header->flags |= header::FREE;
            }

            block_header->flags |= header::FREE;


            if(split) {
                if(prev_block == nullptr){
                    _first = block_header->next;
                } else {
                    get_header(prev_block)->next = block_header->next;

                    if(block == _last)
                        _last = prev_block;
                }

                bool smaller_inserted = false;
                bool bigger_inserted = false;

                void * smaller_block =
                    ( block_header->size <= new_block_header->size
                    ? block
                    : new_block);

                void * bigger_block =
                    ( block_header->size <= new_block_header->size
                    ? new_block
                    : block);

                void * inserted_block = smaller_block;
                header * inserted_block_header = get_header(inserted_block);

                void * lookup_block = _first;
                header * lookup_block_header = get_header(lookup_block);
                void * prev_lookup_block = nullptr;

                while(lookup_block != nullptr){
                    if(inserted_block_header->size < lookup_block_header->size) {
                        inserted_block_header->next = lookup_block;

                        if(prev_lookup_block != nullptr) {
                            header * prev_lookup_block_header =
                                get_header(prev_lookup_block);

                            prev_lookup_block_header->next = inserted_block;
                        } else
                            _first = inserted_block;

                        if(smaller_inserted) {
                            bigger_inserted = true;
                        } else {
                            smaller_inserted = true;

                            prev_lookup_block = inserted_block;
                            inserted_block = bigger_block;
                            continue;
                        }
                        break;
                    }

                    prev_lookup_block = lookup_block;
                    lookup_block = get_header(lookup_block)->next;
                    lookup_block_header = get_header(lookup_block);
                }

                if(!smaller_inserted) {
                    get_header(_last)->next = smaller_block;
                    _last = smaller_block;
                }

                if(!bigger_inserted) {
                    get_header(_last)->next = bigger_block;
                    _last = bigger_block;
                }
            }

            return block;
        }

        prev_block = block;
        block = block_header->next;
    } while(block != nullptr);

    return nullptr;
}

linked_list_allocator::header * linked_list_allocator::get_header(void * addr)
{
    return ((header*) align_back((void*)((byte*)addr - sizeof(header) + 8), alignof(header)));
}
